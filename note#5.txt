class person <- class Student <- class StudentWorker
말하기 먹기      공부하기		일하기
걷기 잠자기 
	    <- class Researcher <- class Professor
		연구하기		가르치기
class Student: public Person{study}

업캐스팅: 파생 클래스 포인터 -> 기본 클래스 포인터 
				p* pBase = &cp
다운캐스팅: 기본 클래스 포인터 -> 파생 클래스 포인터 [강제 타입 변환 해야함
				pDer = (cp*)pBase

상속: 클래스 사이에서 상속관계
객체 사이에서는 상속 관계 없음 그래서 예제 8-2: 5,6에	 ColorPoint cp는
						파생 클래스의 객체를
						생성한거라 상속 관계 없음

protected 멤버는 파생 클래스가 아닌 다른 클래스나 외부 함수에서는 접근 불가
private 멤버는 선언된 클래스 내에서만 접근 가능
public 외부 클래스, 외부 함수 접근 가능

생성자 호출, 실행, 소멸 순서 20p
파생 클래스 객체 소멸될 때 파생 클래스 소멸자 먼저 실행 기본 클래스 소멸자 나중에 실행

기본 클래스에 기본 생성자가 있으면 묵시적으로 기본 생성자를 호출
기본 클래스에 기본 생성자가 없으면 컴파일 에러
파생 클래스에 매개 변수를 가진 생성자도 묵시적으로 기본 생성자를 호출함
파생 클래스에서 기본 클래스의 생성자를 선택해서 호출해야함 ex) B(int x) : A(x+3)

상속 선언할 때 멤버의 접근 속성을 어떻게 계승할지 지정가능
상속이 중첩될 시 grandderived 두번째 상속 클래스에서 클래스끼리 상속될 때 주의
접근 지정자에 따라 다름

상속 지정할 떄 protected멤버들을 public으로 상속하면 기존 protected멤버들이 모든 외부함수나 외부 클래스에서 접근이 가능한데 실제로 사용할 떄 굳이 이런 식으로 바꿀 필요가 있을까 생각을 해봤는데 없을 줄 알았는데 예를 들면 커뮤니티 같은 곳에 올리는 게시글들이 비공개일 때는 본인과 관리자만 볼 수 있으니 protected와 같은 느낌이고 공개로 돌리면 접근 권한이 public이니 굳이굳이 꼽자면 있겠구나 

다중 상속을 사용할때 정확하게 명시해주지 않으면 문제가 생기고
다중 상속시 모호성은 virtual 선언으로 해결

