프렌드 함수는 클래스의 멤버 함수가 아닌 외부 함수로, 키워드를 통해 클래스의 멤버에 접근할 수 있는 권한을 부여받음
외부함수, 클래스의 멤버 함수, 클래스의 모든 멤버 함수 초대가능
프렌드 함수 선언은 캡슐화를 깨는 것이므로 주의 필요
클래스와 구조체의 차이는 기본 private, public

연산자 중복
정수 더하기, 문자열 합치기, 색 섞기, 배열 합치기
중복 가능 연산자, 불가 연산자 존재,

연산자 함수 구현은 클래스의 멤버 함수, 외부함수를 프렌드 함수로

리턴타입 operator연산자(매개변수);

이항 연산자 중복: +연산자 c = a +(b);
피연산자 b가 Power operator+ (Power op2);의 op2에 전달,
+는 operator+

==연산자 함수 선언 후 ==연산자 멤버 함수 구현 후
operator==()형식 멤버 함수 호출 

==연산자 중복: a.==(b)
리턴 타입, 피연산자 b, 

+=연산자 중복: c=a+=(b)
Power&operator+=(Power op2);
리턴타입, 연산자, 피연산자 b가 op2에 전달

단항 연산자: 피연산자가 하나 뿐인 연산자
종류 : 	전위 연산자: !op, ~op, ++op, --op
	후위 연산자: op++, op--

전위 ++연산자 중복, 매개변수 없음, 멤버 함수 구현 시 변경된 객체 자신의 참조 리턴, !->boolean, 

후위 연산자 중복, ++연산자:
매개변수 존재, tmp로 객체 상태 저장 등 구현 가능, 예제에서는 후위 연산자 멤버 함수를 구현하면 각각 kick++, punch++가 진행되지만, b에는 a가 증가되기 이전 상태를 리턴 받아 b를 출력하면 a++가 진행되기 전 a출력됨.

프렌드를 이용한 연산자중복:
+연산자 함수를 외부함수로 구현, 괄호안의 매개변수, 클래스의 kick, punch에 접근하기 위해 연산자 operator+를 friend로 선언
연산자 함수를 프렌드로 작성, 연산자 함수 구현, 연산자 함수를 프렌드로 선언 후
operator+( , ) 형식으로 호출 후 구현,

단항 연산자 ++를 프렌드로 작성하면, 전위 연산자는 연산자 함수 실행 후 연산결과 리턴, 후위 연산자는 연산자 함수 실행 후 변경 이전의 상태 리턴

참조를 리턴하는 <<연산자:
Power& Power::operator<<(int i){
구현부}

[객체 리턴, 참조]




