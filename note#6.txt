가상 함수: virtual 키워드로 선언된 멤버 함수, 동적 바인딩 지시어, 런타임시 오버라이드를 하게 되면 
오버라이딩은 베이스 클래스는 인터페이스 원형의 모양, 파생 클래스에 구현을 하는셈, 선언과 구현 분리.  파생 클래스에서 오버라이딩한 함수가 호출되도록 동적 바인딩, 
base클래스의 함수를 호출하면 파생클래스의 함수가 불려감 외부클래스에서 함수를 호출하면, 
코드 상에서는 키워드, 오버라이딩은 컴파일시에 미뤄지고 런타임시 동적 바인딩이 일어남, '자바는 그냥 오버라이딩

상속이 반복될 때 오버라이딩 시 지시어 생략 가능, 가상 함수에서 지시어 선언하면 파생 클래스에서 생략 가능. 

상속 관계의 세 클래스가 있을 때 첫 클래스에 virtual 선언을 하게 되면 모두 상속되어 f()선언하면 모두 자손 클래스를 호출함, 그런데 virtual 선언을 하지 않으면, 각각 알아서 클래스를 호출하게 됨

오버라이딩과 범위 지정 연산자(::)
정적 바인딩 지시: 컴파일 타임에 호출. 
class Shape {
 public:
	virtual void draw() {
...
}
};
class Circle : public Shape {
public:
 virtual void draw() {
	Shape::draw(); // 기본 클래스의 draw()를 실행한다.
		.... // 기능을 추가한다.
	}
};

가상 소멸자,,
파생에서 소멸을 하면 파생도 소멸, 베이스도 소멸, 결과적으로는 파생을 소멸하던 베이스를 소멸하던 둘다 같다.

순수 가상 함수, 
class Shape {
public:
virtual void draw()=0; // 순수 가상 함수 선언
};

추상 클래스 : 최소한 하나의 순수 가상 함수를 가진 클래스
추상 클래스는 온전한 클래스가 아니라 객체 생성 불가능, 포인터는 선언 가능.
목적은 인스턴스(객체)를 생성할 목적이 아니라 인터페이스 역할->파생 클래스에서 구현할 함수의 원형을 보여주는 역할. 
선언부와 구현부를 분리하는 느낌으로 사용함
